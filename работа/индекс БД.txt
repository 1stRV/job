*Индекс
объект БД для ускорения поиска данных.

индекс имеет структуру, оптимизированную под поиск — например, в сбалансированном дереве.

Индекс ускоряет запросы, предоставляя быстрый доступ к строкам данных в таблице
аналогично тому, как предметный указатель в книге помогает вам быстро найти желаемую информацию

*DBRefs
ссылки из одного документа в другой с использованием значения поля первого документа_id, имени коллекции и, необязательно, имени базы данных. Включая эти имена, DBRefs позволяет легче связывать документы, расположенные в нескольких коллекциях, с документами из одной коллекции.

Spring-Data отображает ваши Java-объекты на MongoDB

У Mongo есть 

В реляционных БД связь таблиц реализуется внешними ключами, поля из одной таблицы ссылаются на поля в другой таблице. 

В MongoDB для связей таблиц нужно устанавливать ссылки DBRefs.

В отличие от строк документы могут хранить сложную по структуре информацию.

Документ можно представить как хранилище ключей и значений. 

спользуя функциональность DBRef, мы можем установить автоматическое связывание между документами.


Вопросы:
1)Выбрать иерархическую структуру или DbRefs

https://ru.bmstu.wiki/%D0%98%D0%B5%D1%80%D0%B0%D1%80%D1%85%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F_%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85

*Иерархическая модель(Деревья с ссылкой DbRefs на детей)
В дереве, в каждой вершине хранится ID вершины и ID ее детей. Такая реализация удобна при существовании необходимости часто работать именно с детьми, но не с поддеревьями. Также ее можно использовать для реализации графов, когда у вершины есть несколько родителей.

Для хранения данных Mongo Db использует коллекции вместо таблиц в отличии от Postgresql.

*Шардинг
процесс хранения документов на нескольких серверах и это способ, которым MongoDB справляется с большими данными путём горизонтального масштабирования. Вертикальное масштабирование слишком дорогое

*Конфигурационный сервер
Сервер, который хранит метаданные кластера. Эти данные содержат информацию о маппинге данных кластера на шарды (shards)

*Плюсы Mongo DB
поддержка индексов. 

Для быстрого поиска в Mongo DB мы можем добавить индекс по какому-либо полю. Для индексации используется команда

collection.EnsureIndex(IndexKeys.Descending("weight"));

Это ускорит сортировку по этому полю.

индексация, удаление, вывод азписей в Mongo DB:
https://ru.bmstu.wiki/MongoDB#.D0.9C.D0.BE.D0.B4.D0.B5.D0.BB.D1.8C_.D0.B4.D0.B0.D0.BD.D0.BD.D1.8B.D1.85

*в конспект наслед, комп, агрегация:
Агрегация: профессора - факультеты, профессора остаются жить после разрушения факультета
Композиция: университет - факультеты, факультеты без университета погибают.




Выборка
Предположим нам надо выбрать все документы из определенной коллекции у которых значение city равно "Moscow".
В SQL нам приходится прибегать к инструкции JOIN, т.к. в унифицированной системе наподобие друпала мы не всегда можем записать всю информацию в одну таблицу. 


По аналогии с JOIN мы также можем создавать ссылки на объекты других коллекций, и нам не придется делать отдельные запросы для получения связанных документов.


MongoDB хорошо справляется с большим количеством документов (миллионы), скорость выборки как и в SQL оптимизируется индексами, лимитами на количество получаемых документов за один запрос, как и в привычных реляционных БД индексы отрицательно влияют на скорость записи.


*В SQL есть оператор INSERT для добавления и UPDATE для обновления записей.
Запись в MongoDB Выполняется при помощи трех функций: insert - добавление, save и update - для обновление и добавление.


Функция save это враппер для update, упрощающий синтаксис команды.
Примеры:


// $doc - произвольный документ

// Вставить документ
db.insert($doc);

// Обновить документ или добавить новый если его не существует, 2 варианта
db.save($doc);
// или
db.update({name: "Joe"}, $doc, true); // первый аргумент - условие, второй - новый документ, третий - вставка если исходный документ не найден

// Атомарная операция. Увеличить параметр counter на единицу
db.update({name: "Joe"}, {$inc : {counter : 1}});



Агрегация
Допустим, перед нами стоит задача: мы имеем таблицу с комментариями, надо выбрать суммарное количество голосов за каждого автора.

В SQL это решается довольно просто, как-то так:


SELECT author, SUM(votes) FROM comments GROUP BY author;
В MongoDB реализация посложнее но более мощная. Называется она Map/Reduce.
Говоря простым языком это альтернатива оператора GROUP BY и функций-агрегаторов (SUM, MAX, MIN, ...) для NoSQL (в нашем контексте). В общих чертах как происходит эта операция:

Сначала выбираются необходимые документы из БД. Т.к. это по сути обычный запрос на выборку, к нему подходят общие правила оптимизации подобных операций, такие как добавление индексов и лимитирование количества выбираемых данных.
На языке JavaScript создается функция map, которая проходит по каждому документу, найденному на предыдущем шаге, и собирает необходимую информацию для агрегации.
На том же самом JS создается функция reduce, которая получает данные маппинга, сгруппированные по какому-то определенному в функции map ключу. Происходит долгожданная агрегация данных.
При желании можно определить функцию finalize, которая будет запускаться после reduce и производить финальные действия над данными.
Получаем результат агрегации и используем его в нашем приложении



Например, есть поля 
@id String id; 
@Indexed String name; 

Если запросить индексы db.user.getIndexes();
[
    {
        "v" : 1,
        "key" : {
             "_id" : 1
         },
        "name" : "_id_",
        "ns" : "test.user"
    },
    {
         "v" : 1,
         "key" : {
             "name" : 1
          },
          "name" : "name",
          "ns" : "test.user"
     }
]

Здесь есть несколько вариантов структур дерева моделей:
https://docs.mongodb.com/manual/tutorial/model-tree-structures-with-child-references/

расписать Mongo по пунктам по видам моделей и отношей и тюд.


https://www.baeldung.com/cascading-with-dbref-and-lifecycle-events-in-spring-data-mongodb


